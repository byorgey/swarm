A few principles to guide the development and design of the game.

- Above all, the game should be fun! (But it's OK if it's only fun to
  a certain kind of nerd.)

- The game is, first and foremost, a *programming* game, and it should
  promote the exploration and use of various sorts of programming
  abstractions.  In other words, it should reward finesse in writing
  sophsticated robot programs, as opposed to e.g. throwing a ton of
  robots at things by brute force (though it's OK if some brute force
  is required as well).

- Don't provide complex built-in features; instead, provide simple,
  fundamental, composable pieces out of which users can build the
  complex features themselves.

- There should be multiple viable paths to upgrading and building more
  abstractions.  In other words, we *don't* want a linear chain of
  achievements, where you *must* enable language feature X in order to
  obtain resource Y, which you need in order to enable language
  feature Z, which you need in order to... and so on.  Some of this
  will probably happen organically---it would probably be impossible
  to enforce a strictly linear chain of achievements even if we wanted
  to---but it's worth reflecting on explicitly.

- Ideally, everything in the game---including both entities and
  programming language features---should be discoverable just by
  playing.

- The activities of adding more programming language features, adding
  new kinds of entities and recipes, and adding new things to the
  generated worlds are all inextricably linked, and should be done
  deliberately.  It will probably require a lot of experimentation and
  tweaking to balance things so that gameplay is interesting and
  challenging but not overly difficult.
