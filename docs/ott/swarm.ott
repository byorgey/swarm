% -*- compile-command: "ott -tex_show_meta false -i swarm.ott -o swarm.tex && pdflatex swarm.tex" -*-

embed
  {{ tex-preamble
\DeclareMathAlphabet{\mathbbold}{U}{bbold}{m}{n}
\usepackage{stmaryrd}
  }}

metavar termvar, x, f ::=
  {{ tex \mathit{[[termvar]]} }} {{ com  term variable  }}

metavar typevar, a {{ tex \alpha }}, bb {{ tex \beta }} ::=
  {{ tex \mathit{[[typevar]]} }} {{ com  type variable  }}

metavar capvar, dd {{ tex \delta }} ::=
  {{ tex \mathit{[[capvar]]} }} {{ com   capability variable }}

metavar integer, i ::=
  {{ tex \mathit{[[integer]]} }} {{ com  integer }}

metavar s ::=
  {{ tex \mathit{[[s]]} }} {{ com string }}

metavar b ::=
  {{ tex \mathit{[[b]]} }} {{ com boolean }}

indexvar j, k ::=
  {{ com  index }}

grammar
  terminals :: 'terminals_' ::=
    | \                   ::   :: lambda     {{ tex \lambda }}
    | <-                  ::   :: gets       {{ tex \leftarrow }}
    | *                   ::   :: prod       {{ tex \times }}
    | ->                  ::   :: arr        {{ tex \to }}
    | empty               ::   :: empty      {{ tex \bullet }}
    | U                   ::   :: union      {{ tex \cup }}
    | |>                  ::   :: cons       {{ tex \triangleright }}
    | |-                  ::   :: shows      {{ tex \vdash }}
    | |-c                 ::   :: showsc     {{ tex \vdash_c }}
    | elem                ::   :: in         {{ tex \in }}
    | ;;                  ::   :: bind       {{ tex \fatsemi }}
    | forall              ::   :: forall     {{ tex \forall }}

  const, K :: 'const_' ::=                              {{ com constants }}
    | noop                ::   :: noop                    {{ com no-op }}
    | wait                ::   :: wait                    {{ com wait }}
    | selfdestruct        ::   :: selfdestruct            {{ com self destruct }}
    | move                ::   :: move                    {{ com move }}
    | turn                ::   :: turn                    {{ com turn }}
    | grab                ::   :: grab                    {{ com grab }}
    | place               ::   :: place                   {{ com place }}
    | give                ::   :: give                    {{ com give }}
    | install             ::   :: install                 {{ com install }}
    | make                ::   :: make                    {{ com make }}
    | has                 ::   :: has                     {{ com inventory test }}
    | count               ::   :: count                   {{ com inventory count }}
    | drill               ::   :: drill                   {{ com drill }}
    | build               ::   :: build                   {{ com build }}
    | salvage             ::   :: salvage                 {{ com salvage }}
    | reprogram           ::   :: reprogram               {{ com reprogram }}
    | say                 ::   :: say                     {{ com say }}
    | log                 ::   :: log                     {{ com log }}
    | view                ::   :: view                    {{ com view }}
    | appear              ::   :: appear                  {{ com appear }}
    | create              ::   :: create                  {{ com create }}
    | whereami            ::   :: whereami                {{ com location query }}
    | blocked             ::   :: blocked                 {{ com front query }}
    | scan                ::   :: scan                    {{ com scan }}
    | upload              ::   :: upload                  {{ com upload }}
    | ishere              ::   :: ishere                  {{ com cell query }}
    | whoami              ::   :: whoami                  {{ com self name query }}
    | random              ::   :: random                  {{ com random }}
    | run                 ::   :: run                     {{ com run }}
    | if                  ::   :: if                      {{ com if }}
    | inl                 ::   :: inl                     {{ com left injection }}
    | inr                 ::   :: inr                     {{ com right injection }}
    | case                ::   :: case                    {{ com case analysis }}
    | pair                ::   :: pair                    {{ com pair formation }}
    | fst                 ::   :: fst                     {{ com first projection }}
    | snd                 ::   :: snd                     {{ com second projection }}
    | force               ::   :: force                   {{ com force }}
    | return              ::   :: return                  {{ com return }}
    | try                 ::   :: try                     {{ com try }}
    | raise               ::   :: raise                   {{ com raise exception }}
    | not                 ::   :: not                     {{ com not }}
    | neg                 ::   :: neg                     {{ com negate }}
    | eq                  ::   :: eq                      {{ com equal to }}
    | neq                 ::   :: neq                     {{ com not equal to }}
    | lt                  ::   :: lt                      {{ com less than }}
    | gt                  ::   :: gt                      {{ com greater than }}
    | leq                 ::   :: leq                     {{ com less-or-equal }}
    | geq                 ::   :: geq                     {{ com greater-or-equal }}
    | add                 ::   :: add                     {{ com addition }}
    | sub                 ::   :: sub                     {{ com subtraction }}
    | mul                 ::   :: mul                     {{ com multiplication }}
    | div                 ::   :: div                     {{ com division }}
    | exp                 ::   :: exp                     {{ com exponentiation }}

  d :: 'd_' ::=                                         {{ com direction }}
    | left                ::   :: lft
    | right               ::   :: rgt
    | back                ::   :: back
    | forward             ::   :: forward
    | north               ::   :: north
    | south               ::   :: south
    | east                ::   :: east
    | west                ::   :: west
    | down                ::   :: down

  term, t :: 't_' ::=                                   {{ com term }}
    | ()                  ::   :: unit                    {{ com unit value }}
    | K                   ::   :: const                   {{ com constant }}
    | d                   ::   :: dir                     {{ com direction literal }}
    | i                   ::   :: int                     {{ com integer literal }}
    | s                   ::   :: str                     {{ com string literal }}
    | b                   ::   :: bool                    {{ com boolean literal }}
    | x                   ::   :: var                     {{ com variable }}
    | \ x . t             ::   :: lam  (+ bind x in t +)  {{ com function abstraction }}
    | t1 t2               ::   :: app                     {{ com function application }}
    | let x = t1 in t2    ::   :: let (+ bind x in t2 +)  {{ com let }}
    | def x = t end       ::   :: def                     {{ com definition }}
    | x <- t1 ;; t2       ::   :: bind (+ bind x in t2 +) {{ com bind }}
    | { t }               ::   :: delay                   {{ com delay }}
    | ( t )               :: S :: paren

%     | theta t'            :: M :: tsub
%     | 1                   :: M :: One
%     | [[ t ]]             :: M :: arith                   {{ com arithmetic }}

  % value, v :: 'v_' ::=                                  {{ com value }}
  %   | i                   ::   :: int                     {{ com natural number }}
  %   | x |-> t             ::   :: lam                     {{ com abstraction }}
  %   | ( v1 , v2 )         ::   :: pair                    {{ com pair }}
  %   | inl v               ::   :: inl                     {{ com left introduction }}
  %   | inr v               ::   :: inr                     {{ com right introduction }}

  basety, B :: 'B_' ::=                                 {{ com base type }}
    | ()                  ::   :: unit                    {{ com unit }}
    | int                 ::   :: int                     {{ com integers }}
    | string              ::   :: string                  {{ com strings }}
    | dir                 ::   :: dir                     {{ com directions }}
    | bool                ::   :: bool                    {{ com booleans }}

  type, T {{ tex \tau }} :: 'T_' ::=                    {{ com monotype }}
    | a                   ::   :: var                     {{ com variable }}
    | B                   ::   :: base                    {{ com base type }}
    | cmd ^ D T           ::   :: cmd                     {{ com command type }}
       {{ tex [[cmd]]^{[[D]]}\;[[T]] }}
    | { T } ^ D           ::   :: delay                   {{ com delay type }}
       {{ tex \{ [[T]] \}^{[[D]]} }}
    | T1 + T2             ::   :: sum                     {{ com sum type }}
    | T1 * T2             ::   :: product                 {{ com product type }}
    | T1 -- D --> T2      ::   :: arrow                   {{ com function type }}
      {{ tex [[T1]] \xrightarrow{[[D]]} [[T2]] }}
    | T1 -> T2            ::   :: earrow                  {{ com function type with empty capability set }}
    | ( T )               :: S :: paren

    % | { T / X } T'        :: M :: tysub

  

  polytype, S {{ tex \sigma }} :: 'S_' ::=              {{ com polytype }}
    | T                   ::   :: mono                    {{ com monotype }}
    | forall a1 .. aj dd1 .. ddk . T ::   :: poly         {{ com quantified type }}

  capability, C {{ tex \kappa }} :: 'cap_' ::=            {{ com capability }}
    | GOD                 ::   :: god                     {{ tex \mathsf{GOD} }}
    | SELFDESTRUCT        ::   :: selfdestruct            {{ tex \mathsf{SELFDESTRUCT} }}
    | MOVE                ::   :: move                    {{ tex \mathsf{MOVE} }}
    | TURN                ::   :: turn                    {{ tex \mathsf{TURN} }}
    | GRAB                ::   :: grab                    {{ tex \mathsf{GRAB} }}
    | PLACE               ::   :: place                   {{ tex \mathsf{PLACE} }}
    | GIVE                ::   :: give                    {{ tex \mathsf{GIVE} }}
    | INSTALL             ::   :: install                 {{ tex \mathsf{INSTALL} }}
    | MAKE                ::   :: make                    {{ tex \mathsf{MAKE} }}
    | COUNT               ::   :: count                   {{ tex \mathsf{COUNT} }}
    | BUILD               ::   :: build                   {{ tex \mathsf{BUILD} }}
    | SALVAGE             ::   :: salvage                 {{ tex \mathsf{SALVAGE} }}
    | DRILL               ::   :: drill                   {{ tex \mathsf{DRILL} }}
    | SENSELOC            ::   :: senseloc                {{ tex \mathsf{SENSELOC} }}
    | SENSEFRONT          ::   :: sensefront              {{ tex \mathsf{SENSEFRONT} }}
    | SENSEHERE           ::   :: sensehere               {{ tex \mathsf{SENSEHERE} }}
    | SCAN                ::   :: scan                    {{ tex \mathsf{SCAN} }}
    | RANDOM              ::   :: random                  {{ tex \mathsf{RANDOM} }}
    | APPEAR              ::   :: appear                  {{ tex \mathsf{APPEAR} }}
    | CREATE              ::   :: create                  {{ tex \mathsf{CREATE} }}
    | LOG                 ::   :: log                     {{ tex \mathsf{LOG} }}
    | FLOAT               ::   :: float                   {{ tex \mathsf{FLOAT} }}
    | COND                ::   :: cond                    {{ tex \mathsf{COND} }}
    | COMPARE             ::   :: compare                 {{ tex \mathsf{COMPARE} }}
    | ARITH               ::   :: arith                   {{ tex \mathsf{ARITH} }}
    | ENV                 ::   :: env                     {{ tex \mathsf{ENV} }}
    | LAMBDA              ::   :: lambda                  {{ tex \mathsf{LAMBDA} }}
    | RECURSION           ::   :: recursion               {{ tex \mathsf{RECURSION} }}
    | REPROGRAM           ::   :: reprogram               {{ tex \mathsf{REPROGRAM} }}
    | WHOAMI              ::   :: whoami                  {{ tex \mathsf{WHOAMI} }}

D {{ tex \Delta }} :: 'Cset_' ::=                       {{ com capability set }}
    | empty               ::   :: em                      {{ com empty }}
    | dd                  ::   :: var                     {{ com variable }}
    | C                   ::   :: sing                    {{ com singleton }}
    | D , C               ::   :: snoc                    {{ com snoc }}
    | D1 U D2             :: M :: union
    | ( D )               :: S :: parens

  G {{ tex \Gamma }} :: G_ ::=                          {{ com type context }}
    | empty               ::   :: em                      {{ com empty context }}
    | G , x : T           ::   :: snoc                    {{ com snoc }}


  formula :: 'formula_' ::=
    | judgement            ::   :: judgement
    | x : T elem G         ::   :: xTelemG
    | formula1 .. formulak ::  :: dots
    | ( formula )          :: S :: parens


parsing
  T_arrow left T_earrow
  T_sum left T_arrow

%   uop_neg left t_app    % t1 - t2  should parse as  minus(t1, t2), not app(t1,neg(t2))
%   formula_dots left formula_not

% % subrules
% %   v <:: t
% %   num <:: S

% freevars
%   t x :: fv

% substitutions
%   single t x :: tsubst

defns
  Jsub :: '' ::=

  defn
    |-c K : S :: :: consttype :: ctype_
      {{ com Constant $[[K]]$ has type $[[S]]$ }} by

    ---------------------- :: noop
    |-c noop : cmd ^ empty ()

    ---------------------- :: wait
    |-c wait : int -> cmd ^ empty ()

    ---------------------- :: selfdestruct
    |-c selfdestruct : cmd ^ SELFDESTRUCT ()

    ---------------------- :: move
    |-c move : cmd ^ MOVE ()

    ---------------------- :: turn
    |-c turn : dir -> cmd ^ TURN ()

    ---------------------- :: grab
    |-c grab : cmd ^ GRAB string

    ---------------------- :: place
    |-c place : string -> cmd ^ PLACE ()

    ---------------------- :: give
    |-c give : string -> string -> cmd ^ GIVE ()

    ---------------------- :: install
    |-c install : string -> string -> cmd ^ INSTALL ()

    ---------------------- :: make
    |-c make : string -> cmd ^ MAKE ()

    ---------------------- :: has
    |-c has : string -> cmd ^ empty bool

    ---------------------- :: count
    |-c count : string -> cmd ^ COUNT int

    ---------------------- :: drill
    |-c drill : dir -> cmd ^ DRILL ()

    ---------------------- :: build
    |-c build : forall a dd1 dd2. string -> { cmd ^ dd1 a } ^ dd2 -> cmd ^ BUILD string

    ---------------------- :: salvage
    |-c salvage : cmd ^ SALVAGE ()

    ---------------------- :: reprogram
    |-c reprogram : forall a dd1 dd2. string -> { cmd ^ dd1 a } ^ dd2 -> cmd ^ BUILD ()

    ---------------------- :: say
    |-c say : string -> cmd ^ empty ()

    ---------------------- :: log
    |-c log : string -> cmd ^ LOG ()

    ---------------------- :: view
    |-c view : string -> cmd ^ empty ()

    ---------------------- :: appear
    |-c appear : string -> cmd ^ APPEAR ()

    ---------------------- :: create
    |-c create : string -> cmd ^ GOD ()

    ---------------------- :: blocked
    |-c blocked : cmd ^ SENSEFRONT bool

    ---------------------- :: scan
    |-c scan : dir -> cmd ^ SCAN (() + string)

    ---------------------- :: upload
    |-c upload : string -> cmd ^ SCAN ()

    ---------------------- :: ishere
    |-c ishere : string -> cmd ^ SENSEHERE bool

    ---------------------- :: whereami
    |-c whereami : cmd ^ SENSELOC (int * int)

    ---------------------- :: whoami
    |-c whoami : cmd ^ WHOAMI string

    ---------------------- :: random
    |-c random : int -> cmd ^ RANDOM int

    ---------------------- :: run
    |-c run : string -> cmd ^ empty ()

    ---------------------- :: if
    |-c if : forall a dd . bool -> { a } ^ dd -> { a } ^ dd -- dd --> a

    ---------------------- :: inl
    |-c inl : forall a bb. a -> a + bb

    ---------------------- :: inr
    |-c inr : forall a bb. bb -> a + bb

    ---------------------- :: case
    |-c case : forall a1 a2 bb dd. (a1 -- dd --> bb) -> (a2 -- dd --> bb) -> ((a1 + a2) -- dd --> bb)

    ---------------------- :: pair
    |-c pair : forall a1 a2. a1 -> a2 -> a1 * a2

    ---------------------- :: fst
    |-c fst : forall a1 a2. a1 * a2 -> a1

    ---------------------- :: snd
    |-c snd : forall a1 a2. a1 * a2 -> a2

    ---------------------- :: return
    |-c return : forall a. a -> cmd ^ empty a

    ---------------------- :: try
    |-c try : forall a dd1 dd2 dd3 dd4. { cmd ^ dd1 a } ^ dd2 -> { cmd ^ dd3 a } ^ dd4 -> cmd ^ (dd1 U dd2 U dd3 U dd4) a

    ---------------------- :: raise
    |-c raise : forall a. string -> cmd ^ empty a

    ---------------------- :: not
    |-c not : bool -> bool

    ---------------------- :: eq
    |-c eq : forall a. a -> a -- COMPARE --> bool

    ---------------------- :: neq
    |-c neq : forall a. a -> a -- COMPARE --> bool

    ---------------------- :: lt
    |-c lt : forall a. a -> a -- COMPARE --> bool

    ---------------------- :: gt
    |-c gt : forall a. a -> a -- COMPARE --> bool

    ---------------------- :: leq
    |-c leq : forall a. a -> a -- COMPARE --> bool

    ---------------------- :: geq
    |-c geq : forall a. a -> a -- COMPARE --> bool

    ---------------------- :: neg
    |-c neg : int -- ARITH --> int

    ---------------------- :: add
    |-c add : int -> int -- ARITH --> int

    ---------------------- :: sub
    |-c sub : int -> int -- ARITH --> int

    ---------------------- :: mul
    |-c mul : int -> int -- ARITH --> int

    ---------------------- :: div
    |-c div : int -> int -- ARITH --> int

    ---------------------- :: exp
    |-c exp : int -> int -- ARITH --> int


  defn
    G |- t : S ; D :: :: hastype :: type_
      {{ com In context $[[G]]$, $[[t]]$ has type $[[S]]$, and its evaluation requires capabilites $[[D]]$ }} by

    ---------------------------- :: unit
    G |- () : () ; empty

    ---------------------------- :: dir
    G |- d : dir ; empty

    ---------------------------- :: int
    G |- i : int ; empty

    ---------------------------- :: string
    G |- s : string ; empty

    ---------------------------- :: bool
    G |- b : bool ; empty

    |-c K : T
    ---------------------------- :: const
    G |- K : T ; empty

    x : T elem G
    ---------------------- :: var
    G |- x : T ; empty

    G , x : T1 |- t : T2 ; D
    ------------------------------- :: lam
    G |- \ x . t : T1 -- D --> T2 ; empty

    G |- t1 : T1 -- D1 --> T2 ; D2        G |- t2 : T1 ; D3
    -------------------------------------------------------------------------- :: app
    G |- t1 t2 : T2 ; D1 U D2 U D3

    G |- t1 : T1 ; D1       G , x : T1 |- t2 : T2 ; D2
    ------------------------------------------------------------------- :: let
    G |- let x = t1 in t2 : T2 ; D1 U D2

    G |- t : T ; D
    -------------------------------------------- :: delay
    G |- { t } : { T } ^ D ; empty

    G |- t : { T } ^ D1 ; D2
    ------------------------------------------------------------ :: force
    G |- force t : T ; D1 U D2

    G |- t1 : cmd ^ D11 T1 ; D12          G , x : T1 |- t2 : cmd ^ D21 T2 ; D22
    ----------------------------------------------------------------------------- :: bind
    G |- x <- t1 ;; t2 : cmd ^ (D11 U D12 U D21 U D22) T2 ; empty
